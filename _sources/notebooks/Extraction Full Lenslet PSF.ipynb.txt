{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Populating the interactive namespace from numpy and matplotlib\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "SIMPLE  =                    T / conforms to FITS standard                      \n",
       "BITPIX  =                    8 / array data type                                \n",
       "NAXIS   =                    0 / number of array dimensions                     \n",
       "EXTEND  =                    T                                                  \n",
       "COMMENT                                                                         \n",
       "COMMENT ************************************************************            \n",
       "COMMENT ********************** General parameters ******************            \n",
       "COMMENT ************************************************************            \n",
       "COMMENT                                                                         \n",
       "NLENS   =                  108 / # lenslets across array                        \n",
       "PITCH   =             0.000174 / Lenslet pitch (meters)                         \n",
       "INTERLAC=                  2.0 / Interlacing                                    \n",
       "PHILENS =    26.56505117707799 / Rotation angle of the lenslets (deg)           \n",
       "PIXSIZE =              1.3E-05 / Pixel size (meters)                            \n",
       "LENSAMP =                  0.5 / Lenslet sampling (lam/D)                       \n",
       "LSAMPWAV=                660.0 / Lenslet sampling wavelength (nm)               \n",
       "FWHM    =                  2.0 / FHWM of PSFLet at detector (pixels)            \n",
       "FWHMLAM =                660.0 / Wavelength at which FWHM is defined (nm)       \n",
       "NPIX    =                 1024 / Number of detector pixels                      \n",
       "BW      =                 0.18 / Bandwidth                                      \n",
       "PIXPRLAM=                  2.0 / Pixels per resolution element                  \n",
       "R       =                   50 / Spectral resolution                            "
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import scipy as sp\n",
    "import glob,os\n",
    "%pylab inline --no-import-all\n",
    "plt.rc('font', family='serif', serif='Times',size=15)\n",
    "plt.rc('text', usetex=True)\n",
    "plt.rc('xtick', labelsize=20)\n",
    "plt.rc('xtick.major', size=10)\n",
    "plt.rc('ytick.major', size=10)\n",
    "plt.rc('ytick', labelsize=20)\n",
    "plt.rc('axes', labelsize=20)\n",
    "plt.rc('figure',titlesize=25)\n",
    "plt.rcParams['image.origin'] = 'lower'\n",
    "plt.rcParams['image.interpolation'] = 'nearest'\n",
    "plt.rcParams['axes.linewidth'] = 2.\n",
    "from astropy.io import fits\n",
    "import astropy.units as u\n",
    "import astropy.constants as c\n",
    "import pandas as pd\n",
    "import logging as log\n",
    "from crispy.tools.initLogger import getLogger\n",
    "log = getLogger('main')\n",
    "from crispy.tools.image import Image\n",
    "os.chdir('/Users/mrizzo/IFS/crispy/crispy/WFIRST/')\n",
    "from params import Params\n",
    "par = Params()\n",
    "par.hdr"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Extracting the spectrum from all the microspectra in the PSF at once"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I have the intuition that this improves over extracting from all the microspectra separately and then matched-filtering, although this still remains to be proven.\n",
    "\n",
    "In this notebook, the intention is to implement the new fitting routine, and compare it with the old one.\n",
    "\n",
    "Question: in measuring the spectrum, one usually shows the albedo (divide by the star). Should I do that when comparing the SNR?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Construct the individual PSFs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can do that by propagating individual slices of an off-axis PSF one at a time. This is actually a natural byproduct of the IFS propagator, since it propagates one wavelength at a time and then saves it. We can thus simply tell it to export that intermediate cube."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "main - ERROR - Couldn't create master folder\n"
     ]
    }
   ],
   "source": [
    "offaxis_psf_filename='/Users/mrizzo/IFS/OS5/offaxis/spc_offaxis_psf.fits'\n",
    "folder = '/Users/mrizzo/IFS/Extraction/'\n",
    "try:\n",
    "    os.makedirs(folder)\n",
    "except OSError:\n",
    "    log.error(\"Couldn't create master folder\")\n",
    "    pass\n",
    "\n",
    "from crispy.tools.postprocessing import process_offaxis\n",
    "import glob\n",
    "filelist = glob.glob('/Users/mrizzo/IFS/OS5/with_lowfc/*.fits')\n",
    "reffiles = filelist[:30]\n",
    "fileshape = fits.open(reffiles[0])[0].data.shape\n",
    "BW=0.18\n",
    "lamc=660\n",
    "lamlist = lamc*np.linspace(1.-BW/2.,1.+BW/2.,fileshape[0])*u.nm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "crispy - INFO - Recentering off-axis cube\n",
      "crispy - INFO - Read data from HDU 0 of /Users/mrizzo/IFS/OS5/offaxis/spc_offaxis_psf.fits\n",
      "crispy - INFO - The number of input pixels per lenslet is 5.000000\n",
      "crispy - INFO - Writing data to /Users/mrizzo/IFS/Extraction//offaxiscube.fits\n",
      "crispy - INFO - Constructing off-axis cube at planet separation: 4.44 lam/D (0.26 arcsec, 8.89 lenslets)\n",
      "crispy - INFO - Writing data to /Users/mrizzo/IFS/Extraction//offaxiscube_shifted.fits\n",
      "crispy - ERROR - Unable to write FITS file /Users/mrizzo/IFS/Extraction//offaxiscube_star_processed.fits\n",
      "crispy - INFO - The number of input pixels per lenslet is 5.000000\n",
      "crispy - INFO - Using PSFlet gaussian approximation\n",
      "crispy - WARNING - Assuming slices are evenly spread in wavelengths\n",
      "crispy - INFO - Creating Gaussian PSFLet templates\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Process Consumer-3:\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "Process Consumer-4:\n",
      "Process Consumer-8:\n",
      "Process Consumer-7:\n",
      "Process Consumer-1:\n",
      "Traceback (most recent call last):\n",
      "Traceback (most recent call last):\n",
      "Traceback (most recent call last):\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "Process Consumer-6:\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "Traceback (most recent call last):\n",
      "    self.run()\n",
      "    self.run()\n",
      "    self.run()\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "Process Consumer-2:\n",
      "    self.run()\n",
      "    self.run()\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "    self.result_queue.put(next_task())\n",
      "Process Consumer-5:\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "    self.result_queue.put(next_task())\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    self.result_queue.put(next_task())\n",
      "    self.run()\n",
      "    return self.index, self.func(*self.args)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 211, in propagateLenslets\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    self.result_queue.put(next_task())\n",
      "    self.result_queue.put(next_task())\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    return self.index, self.func(*self.args)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    return self.index, self.func(*self.args)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 211, in propagateLenslets\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/process.py\", line 267, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "    return self.index, self.func(*self.args)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    image[iy1:iy2, ix1:ix2] += val*ndimage.map_coordinates(hires[0,0], [yinterp, xinterp], prefilter=False)/nlam\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 190, in propagateLenslets\n",
      "    self.result_queue.put(next_task())\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 211, in propagateLenslets\n",
      "KeyboardInterrupt\n",
      "    self.run()\n",
      "    return self.index, self.func(*self.args)\n",
      "    if not (Xcoord>0 and Xcoord<imageplane.shape[1] and Ycoord>0 and Ycoord<imageplane.shape[0]):\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    image[iy1:iy2, ix1:ix2] += val*ndimage.map_coordinates(hires[0,0], [yinterp, xinterp], prefilter=False)/nlam\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 211, in propagateLenslets\n",
      "KeyboardInterrupt\n",
      "    return self.index, self.func(*self.args)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 211, in propagateLenslets\n",
      "    self.result_queue.put(next_task())\n",
      "    image[iy1:iy2, ix1:ix2] += val*ndimage.map_coordinates(hires[0,0], [yinterp, xinterp], prefilter=False)/nlam\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/scipy/ndimage/interpolation.py\", line 343, in map_coordinates\n",
      "KeyboardInterrupt\n",
      "    image[iy1:iy2, ix1:ix2] += val*ndimage.map_coordinates(hires[0,0], [yinterp, xinterp], prefilter=False)/nlam\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 22, in run\n",
      "    return self.index, self.func(*self.args)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/scipy/ndimage/interpolation.py\", line 343, in map_coordinates\n",
      "    image[iy1:iy2, ix1:ix2] += val*ndimage.map_coordinates(hires[0,0], [yinterp, xinterp], prefilter=False)/nlam\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 211, in propagateLenslets\n",
      "    self.result_queue.put(next_task())\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/par_utils.py\", line 31, in __call__\n",
      "    return self.index, self.func(*self.args)\n",
      "    image[iy1:iy2, ix1:ix2] += val*ndimage.map_coordinates(hires[0,0], [yinterp, xinterp], prefilter=False)/nlam\n",
      "    output, order, mode, cval, None, None)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/lenslet.py\", line 207, in propagateLenslets\n",
      "KeyboardInterrupt\n",
      "    xinterp = (x[iy1:iy2, ix1:ix2] - xcen[i])*upsample + upsample*npix/2.\n",
      "KeyboardInterrupt\n",
      "KeyboardInterrupt\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/scipy/ndimage/interpolation.py\", line 327, in map_coordinates\n",
      "    coordinates = numpy.asarray(coordinates)\n",
      "    output, order, mode, cval, None, None)\n",
      "  File \"/Users/mrizzo/anaconda2/lib/python2.7/site-packages/numpy/core/numeric.py\", line 531, in asarray\n",
      "KeyboardInterrupt\n",
      "    return array(a, dtype, copy=False, order=order)\n",
      "KeyboardInterrupt\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-3-f5e58d873636>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     11\u001b[0m                 \u001b[0mtarget_star_T\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m5887\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mu\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mK\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget_star_Vmag\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m5.03\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     12\u001b[0m                 \u001b[0mref_star_T\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m9377\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mu\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mK\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mref_star_Vmag\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m2.37\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 13\u001b[0;31m                 tel_pupil_area=3.650265060424805*u.m**2, order=3)\n\u001b[0m",
      "\u001b[0;32m/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/tools/postprocessing.pyc\u001b[0m in \u001b[0;36mprocess_offaxis\u001b[0;34m(par, offaxis_psf_filename, fileshape, lamlist, lamc, outdir_average, Nave, inttime, Nreads, filename, planet_radius, planet_AU, planet_dist_pc, albedo, target_star_T, target_star_Vmag, ref_star_T, ref_star_Vmag, tel_pupil_area, order)\u001b[0m\n\u001b[1;32m   1713\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1714\u001b[0m     \u001b[0mImage\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mofftarget\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwrite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutdir_average\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0;34m'/offaxiscube_star_processed.fits'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mclobber\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1715\u001b[0;31m     \u001b[0mdetectorFrame\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpolychromeIFS\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpar\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mlamlist\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mofftarget\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mQE\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1716\u001b[0m     \u001b[0mdet\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mImage\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdetectorFrame\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mheader\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mpar\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhdr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1717\u001b[0m     \u001b[0mdet\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwrite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutdir_average\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0;34m'/offaxis_star.fits'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mclobber\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/mrizzo/anaconda2/lib/python2.7/site-packages/crispy-0.3-py2.7.egg/crispy/IFS.pyc\u001b[0m in \u001b[0;36mpolychromeIFS\u001b[0;34m(par, inWavelist, inputcube, name, parallel, QE, wavelist_endpts, dlambda, lam_arr, wavecalDir, noRot)\u001b[0m\n\u001b[1;32m    207\u001b[0m             \u001b[0mtasks\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mput\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    208\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mwaveList\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 209\u001b[0;31m             \u001b[0mindex\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpoly\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mresults\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    210\u001b[0m             \u001b[0mpolyimage\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mindex\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpoly\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    211\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/mrizzo/anaconda2/lib/python2.7/multiprocessing/queues.pyc\u001b[0m in \u001b[0;36mget\u001b[0;34m(self, block, timeout)\u001b[0m\n\u001b[1;32m    115\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_rlock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0macquire\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    116\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 117\u001b[0;31m                 \u001b[0mres\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_recv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    118\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sem\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrelease\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    119\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "process_offaxis(par,\n",
    "                offaxis_psf_filename=offaxis_psf_filename,\n",
    "                fileshape=fileshape,\n",
    "                lamlist=lamlist,lamc=lamc,\n",
    "                outdir_average=folder,\n",
    "                Nave=1,inttime=1,Nreads=1,\n",
    "                filename=par.codeRoot+'/Inputs/'+'Jupiter_1x_5AU_90deg.dat',\n",
    "                planet_radius = 1.27, # in R_jup\n",
    "                planet_AU = 3.6,planet_dist_pc=14.1,\n",
    "                albedo=0.28,\n",
    "                target_star_T=5887*u.K, target_star_Vmag=5.03,\n",
    "                ref_star_T=9377*u.K, ref_star_Vmag=2.37,\n",
    "                tel_pupil_area=3.650265060424805*u.m**2, order=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "PSF_cube = fits.open(par.exportDir+'/detectorFramePoly.fits')[1].data\n",
    "PSF_cube_cut = PSF_cube[:,400:620,570:690]\n",
    "PSF = np.zeros_like(PSF_cube_cut)\n",
    "for i in range(PSF.shape[0]):\n",
    "    PSF[i] = PSF_cube_cut[i]/np.sum(PSF_cube_cut[i])\n",
    "print np.amax(PSF[0])\n",
    "plt.figure(figsize=(10,10))\n",
    "plt.imshow(PSF[0],vmax=0.01)\n",
    "plt.colorbar()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "psflets_flat = np.reshape(PSF, (PSF.shape[0], -1))\n",
    "img = fits.open(folder+'offaxis_planet_detector.fits')[1].data[400:620,570:690]\n",
    "imgstar = fits.open(folder+'offaxis_star_detector.fits')[1].data[400:620,570:690]\n",
    "plt.figure(figsize=(10,10))\n",
    "plt.imshow(img)\n",
    "plt.colorbar()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from crispy.tools.reduction import RL,calculateWaveList\n",
    "spec = RL(img,psflets_flat)[0]\n",
    "star = RL(imgstar,psflets_flat)[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(spec)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(lamlist,spec/star)\n",
    "from crispy.tools.inputScene import calc_contrast\n",
    "contrast=calc_contrast(wavelist=lamlist.value,distance=3.6,radius=1.27,filename=par.codeRoot+'/Inputs/'+'Jupiter_1x_5AU_90deg.dat',albedo=0.28)\n",
    "plt.scatter(lamlist,contrast,color='orange')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "\n",
    "def calcSNRtotal(Nelec,subim,psflet_subarr,pixnoise=0,npix=0,Niter=10000,plot=True,indspec=4,vect=None):\n",
    "    #sumpsflets = subim*Nelec+pixnoise+1e-10\n",
    "    N = psflet_subarr.shape[0]\n",
    "    lstsq = np.zeros((N,Niter))\n",
    "    varlstsq = np.zeros((N,Niter))\n",
    "    Rvect = np.zeros((N,Niter))\n",
    "    RLvals = np.zeros((N,Niter))\n",
    "\n",
    "    psflets_flat = np.reshape(psflet_subarr, (psflet_subarr.shape[0], -1))\n",
    "    A = psflets_flat.T\n",
    "\n",
    "    for j in range(Niter):\n",
    "        # subtract mean of background (assumed known)\n",
    "        if j%(max(Niter/10,1))==0: print j,\"/\",Niter\n",
    "#         Nit = np.amax((subim*Nelec+pixnoise)/0.1).astype(int)\n",
    "#         if j%(max(Niter/10,1))==0: print j,\"/\",Niter,\", Nit=\",Nit\n",
    "\n",
    "#         img = np.zeros_like(subim)\n",
    "#         var = np.zeros_like(subim)\n",
    "#         for h in range(Nit):\n",
    "#             frame = np.random.poisson((subim*Nelec+pixnoise)/Nit.astype(float))\n",
    "#             img+= frame\n",
    "#             var += frame**2\n",
    "#         var /= Nit.astype(float)\n",
    "#         var -= (img/Nit.astype(float))**2\n",
    "#         var*=Nit\n",
    "#         img -= pixnoise\n",
    "        img = np.random.poisson(subim*Nelec+pixnoise)\n",
    "    ### WATCH OUT, USING NELEC HERE IS CHEATING ###\n",
    "        sumpix = np.sum(img-pixnoise)\n",
    "        guess = np.ones(N)*sumpix/float(N)\n",
    "        \n",
    "        rl = RL(img,psflets=psflet_subarr,prior=pixnoise,guess=guess,niter=30)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "        RLvals[:,j] = rl\n",
    "        variance = np.reshape(np.sum(psflet_subarr*rl[:,np.newaxis,np.newaxis],axis=0)+pixnoise,-1)\n",
    "#         variance = np.reshape(img,-1)\n",
    "        img -= pixnoise\n",
    "\n",
    "#         variance = np.reshape(var,-1)\n",
    "#         variance = np.reshape(img,-1)\n",
    "#         img-=pixnoise\n",
    "        Ninv = np.diag(1./(variance+1e-10))\n",
    "        Cinv = np.dot(np.transpose(A),np.dot(Ninv,A))\n",
    "        C = np.linalg.inv(Cinv)\n",
    "        Q = sp.linalg.sqrtm(Cinv)\n",
    "        s = np.sum(Q,axis=0)\n",
    "        R = Q/s[:,np.newaxis]\n",
    "        #Ctilde = np.diag(1./(s**2+1e-10)\n",
    "        varlstsq[:,j] = 1./(s**2+1e-10)\n",
    "        x = np.reshape(img,-1)\n",
    "        right = np.dot(np.transpose(A),np.dot(Ninv,x))\n",
    "        f = np.dot(C,right)\n",
    "#         rl = RL(img,psflets=psflet_subarr)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "#         RLvals[:,j] = rl\n",
    "        \n",
    "#         lstsq[:,j] = np.dot(C,right)#np.dot(R,f)\n",
    "        lstsq[:,j] = np.dot(R,f)\n",
    "        #RLvals[:,j] = RL(img+pixnoise,psflets=psflet_subarr,prior=pixnoise,guess=lstsq[:,j],niter=10)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "\n",
    "#         RLvals[:,j] = np.dot(R,RLvals[:,j])\n",
    "        if vect is not None: Rvect[:,j] = np.dot(R,vect)\n",
    "\n",
    "\n",
    "    estSNRlstsq = np.mean(lstsq,axis=1)/np.std(lstsq,axis=1)\n",
    "    estSNRRL = np.mean(RLvals,axis=1)/np.std(RLvals,axis=1)\n",
    "#     estSNROptExt = np.mean(0.5*(optext[13,:]+optext[14,:]))/np.std(0.5*(optext[13,:]+optext[14,:]))\n",
    "    if plot:\n",
    "        plt.figure(figsize=(10,10))\n",
    "        plt.imshow(img)\n",
    "        plt.colorbar()\n",
    "        plt.figure(figsize=(15,10))\n",
    "        plt.subplot(121)\n",
    "        res = img-np.reshape(np.dot(A,lstsq[:,j]),subim.shape)\n",
    "        plt.imshow(res)\n",
    "        Npix = np.prod(res.shape)\n",
    "        plt.title('Residuals with lstsq algorithm: $\\chi^2$=%.2f'%np.sum(res**2/np.reshape(np.dot(A,lstsq[:,j])+pixnoise,subim.shape)/Npix))\n",
    "\n",
    "        plt.colorbar(fraction=0.046, pad=0.04)\n",
    "        plt.subplot(122)\n",
    "        res = img-np.reshape(np.dot(A,RLvals[:,j]),subim.shape)\n",
    "        plt.imshow(res)\n",
    "        plt.title('Residuals with EM algorithm: $\\chi^2$=%.2f'%np.sum(res**2/np.reshape(np.dot(A,RLvals[:,j])+pixnoise,subim.shape)/Npix))\n",
    "        plt.colorbar(fraction=0.046, pad=0.04)\n",
    "        plt.figure(figsize=(15,10))\n",
    "#         plt.subplot(121)\n",
    "#         lamlist,_ = calculateWaveList(par,method='lstsq')\n",
    "#         plt.plot(lstsq[:,-1])\n",
    "#         plt.plot(RLvals[:,-1])\n",
    "#         scale = np.mean(RLvals[:,-1])/np.mean(optext[4:-4,-1])\n",
    "#         plt.plot(lamlist,scale*optext[3:-3,-1])\n",
    "#         print np.mean(RLvals[:,-1]),np.mean(optext[4:-4,-1])\n",
    "\n",
    "        SNR = Nelec/(np.sqrt(Nelec+npix*pixnoise))\n",
    "        print \"Expected SNR:\",np.mean(Rvect,axis=1)[indspec]/np.sqrt(np.mean(Rvect,axis=1)[indspec]+npix*pixnoise)\n",
    "        print \"Estimated SNR lstsq:\",estSNRlstsq[indspec]\n",
    "        print \"Estimated SNR RL:\",estSNRRL[indspec]\n",
    "        if vect is not None:\n",
    "            varray = np.array(vect)+1e-10\n",
    "            fchi2 = Rvect[:,-1]\n",
    "#             plt.subplot(122)\n",
    "            plt.plot(fchi2,label='Input')\n",
    "#             plt.plot(lstsq[:,-1])\n",
    "            plt.errorbar(np.arange(N),lstsq[:,-1],yerr=np.sqrt(varlstsq[:,-1]),label='last lstsq trial')\n",
    "            plt.plot(np.arange(N),np.mean(lstsq,axis=1),'o',label='lstsq samp. mean')\n",
    "            plt.fill_between(np.arange(N), np.mean(lstsq,axis=1)-np.std(lstsq,axis=1), np.mean(lstsq,axis=1)+np.std(lstsq,axis=1),alpha=0.3,facecolor='Gray',label='lstsq samp. 1sigma')\n",
    "            plt.errorbar(np.arange(N),np.mean(RLvals,axis=1),yerr=np.std(RLvals,axis=1),fmt='o',label='EM samp. mean')\n",
    "            plt.plot(RLvals[:,-1],label='last EM trial')\n",
    "            plt.legend()\n",
    "            \n",
    "#             print \"MSE lstsq:\",np.sum((estSNRlstsq-fchi2)**2)/np.sum(fchi2**2)\n",
    "#             print \"MSE RL:\",np.sum((estSNRRL-fchi2)**2)/np.sum(fchi2**2)\n",
    "#             print \"MSE lstsq estimated:\",np.mean(np.sum((lstsq-Rvect)**2,axis=0)/np.sum(Rvect**2,axis=0))\n",
    "#             print \"MSE RL estimated:\",np.mean(np.sum((RLvals-Rvect)**2,axis=0)/np.sum(Rvect**2,axis=0))\n",
    "            print \"Average $\\chi^2$ lstsq estimated:\",np.mean(np.sum((lstsq-Rvect)**2/varlstsq,axis=0))/N\n",
    "            print \"Average $\\chi^2$ RL estimated:\",np.mean(np.sum((RLvals-Rvect)**2/varlstsq,axis=0))/N\n",
    "#             print \"MSRE lstsq normalized:\",np.std((estSNRlstsq-varray)/varray)\n",
    "#             print \"MSRE RL normalized:\",np.std((estSNRRL-varray)/varray)\n",
    "            \n",
    "        \n",
    "#         print \"Estimated SNR OptExt:\",estSNROptExt\n",
    "        if vect is not None: print \"Expected mean:\",np.mean(Rvect[indspec])\n",
    "        print \"Estimated mean lstsq:\",np.mean(lstsq,axis=1)[indspec]\n",
    "        print \"Estimated mean RL:\",np.mean(RLvals,axis=1)[indspec]\n",
    "#         print pd.DataFrame(R)\n",
    "#         print np.sum(R,axis=0)\n",
    "#         print R[0],np.sum(R[0])\n",
    "#         print \"Estimated mean:\",np.mean(0.5*(optext[13,:]+optext[14,:]))\n",
    "\n",
    "    return estSNRlstsq,estSNRRL,Rvect#,estSNROptExt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.imshow(image)\n",
    "plt.colorbar()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "indspec=8\n",
    "SNR = np.mean(rvect,axis=1)[indspec]/np.sqrt(np.mean(rvect,axis=1)[indspec]+28*100)\n",
    "print SNR"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.arange(45)\n",
    "print x\n",
    "print x[::2]\n",
    "print x[:-1:2]\n",
    "print x[1::2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "# subPSF = PSF[:-1:2,:,:]+PSF[1::2,:,:]\n",
    "# subPSF = (PSF[::3,:,:]+PSF[1::3,:,:]+PSF[2::3,:,:])/3.\n",
    "# subPSF = PSF[:,:,:]#+PSF[1::3,:,:]+PSF[2::3,:,:])/3.\n",
    "subPSF = (PSF[:-1:2,:,:]+PSF[1::2,:,:])\n",
    "# newsubPSF = np.zeros((subPSF.shape[0]+1,subPSF.shape[1],subPSF.shape[2]))\n",
    "# newsubPSF[:-1,:,:] = subPSF\n",
    "# newsubPSF[-1,:,:] = 1.#/np.prod(PSF.shape[1:])\n",
    "# subPSF = newsubPSF\n",
    "subPSF = PSF[:,:,:]\n",
    "\n",
    "v = np.ones(len(lamlist))\n",
    "spec2 = spec.copy()\n",
    "# spec2[:2] = 0.0\n",
    "spec2[-1] = 0.0\n",
    "v = spec2/np.amax(spec2)\n",
    "\n",
    "Nelec = 500\n",
    "pixnoise= 100\n",
    "# vect2 = (v[::3]+v[1::3]+v[2::3])\n",
    "vect2 = 0.5*(v[:-1:2]+v[1::2])*Nelec#+v[2::3]\n",
    "# newvect2 = np.zeros(vect2.shape[0]+1)\n",
    "# newvect2[:-1] = vect2*Nelec\n",
    "# newvect2[-1] = 100\n",
    "# vect2 = newvect2\n",
    "vect2 = v*Nelec\n",
    "image = np.sum(PSF*v[:,np.newaxis,np.newaxis],axis=0)\n",
    "image[image<0]=1e-10\n",
    "estSNRlstsq,estSNRRL,rvect=calcSNRtotal(Nelec=Nelec,\n",
    "        subim=image,\n",
    "        psflet_subarr=subPSF,\n",
    "        pixnoise=pixnoise,\n",
    "        npix=28,\n",
    "        plot=True,\n",
    "        Niter=100,\n",
    "        indspec=8,\n",
    "        vect = vect2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(10,10))\n",
    "plt.imshow(estSNRlstsq)\n",
    "plt.colorbar()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "\n",
    "def calcSNREM(Nelec,subim,psflet_subarr,pixnoise=0,npix=0,Niter=10000,plot=True,indspec=4,vect=None):\n",
    "    #sumpsflets = subim*Nelec+pixnoise+1e-10\n",
    "    N = psflet_subarr.shape[0]\n",
    "    lstsq = np.zeros((N,Niter))\n",
    "    varlstsq = np.zeros((N,Niter))\n",
    "    Rvect = np.zeros((N,Niter))\n",
    "    RLvals = np.zeros((N,Niter))\n",
    "\n",
    "    psflets_flat = np.reshape(psflet_subarr, (psflet_subarr.shape[0], -1))\n",
    "    A = psflets_flat.T\n",
    "    img = np.random.poisson(subim*Nelec+pixnoise)\n",
    "    img -= pixnoise\n",
    "    rl = RL(img,psflets=psflet_subarr,prior=0.0)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "    RLvals[:,0] = rl\n",
    "    variance = np.reshape(np.sum(psflet_subarr*rl[:,np.newaxis,np.newaxis],axis=0),-1)+pixnoise\n",
    "    Ninv = np.diag(1./(variance+1e-10))\n",
    "    Cinv = np.dot(np.transpose(A),np.dot(Ninv,A))\n",
    "    C = np.linalg.inv(Cinv)\n",
    "    Q = sp.linalg.sqrtm(Cinv)\n",
    "    s = np.sum(Q,axis=0)\n",
    "    R = Q/s[:,np.newaxis]\n",
    "    x = np.reshape(img,-1)\n",
    "    right = np.dot(np.transpose(A),np.dot(Ninv,x))\n",
    "    f = np.dot(C,right)\n",
    "    lstsq[:,0] = np.dot(R,f)\n",
    "    \n",
    "    for j in range(1,Niter):\n",
    "        if j%(max(Niter/10,1))==0: print j\n",
    "        # subtract mean of background (assumed known)\n",
    "#         Nit = np.amax((subim*Nelec+pixnoise)/0.1).astype(int)\n",
    "#         img = np.zeros_like(subim)\n",
    "#         var = np.zeros_like(subim)\n",
    "#         for h in range(Nit):\n",
    "#             frame = np.random.poisson((subim*Nelec+pixnoise)/Nit.astype(float))\n",
    "#             img+= frame\n",
    "#             var += frame**2\n",
    "#         var /= Nit.astype(float)\n",
    "#         var -= (img/Nit.astype(float))**2\n",
    "#         var*=Nit\n",
    "#         img -= pixnoise\n",
    "        img = np.random.poisson(subim*Nelec+pixnoise)#-pixnoise\n",
    "        img-=pixnoise\n",
    "        rl = RL(img,psflets=psflet_subarr,prior=0.0)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "        RLvals[:,j] = rl\n",
    "        variance = np.reshape(np.sum(psflet_subarr*rl[:,np.newaxis,np.newaxis],axis=0),-1)\n",
    "        Ninv = np.diag(1./(variance+1e-10))\n",
    "        Cinv = np.dot(np.transpose(A),np.dot(Ninv,A))\n",
    "        C = np.linalg.inv(Cinv)\n",
    "        Q = sp.linalg.sqrtm(Cinv)\n",
    "        s = np.sum(Q,axis=0)\n",
    "        R = Q/s[:,np.newaxis]\n",
    "        #Ctilde = np.diag(1./(s**2+1e-10)\n",
    "        varlstsq[:,j] = 1./(s**2+1e-10)\n",
    "        x = np.reshape(img,-1)\n",
    "        right = np.dot(np.transpose(A),np.dot(Ninv,x))\n",
    "        f = np.dot(C,right)\n",
    "        \n",
    "#         lstsq[:,j] = np.dot(C,right)#np.dot(R,f)\n",
    "        lstsq[:,j] = np.dot(R,f)\n",
    "        RLvals[:,j] = np.dot(R,RLvals[:,j])\n",
    "        if vect is not None: Rvect[:,j] = np.dot(R,vect)\n",
    "\n",
    "\n",
    "    estSNRlstsq = np.mean(lstsq,axis=1)/np.std(lstsq,axis=1)\n",
    "    estSNRRL = np.mean(RLvals,axis=1)/np.std(RLvals,axis=1)\n",
    "#     estSNROptExt = np.mean(0.5*(optext[13,:]+optext[14,:]))/np.std(0.5*(optext[13,:]+optext[14,:]))\n",
    "    if plot:\n",
    "        plt.figure(figsize=(10,10))\n",
    "        plt.imshow(img)\n",
    "        plt.colorbar()\n",
    "        plt.figure(figsize=(15,10))\n",
    "        plt.subplot(121)\n",
    "        res = img-np.reshape(np.dot(A,lstsq[:,j]),subim.shape)\n",
    "        plt.imshow(res)\n",
    "        Npix = np.prod(res.shape)\n",
    "        plt.title('Residuals with lstsq algorithm: $\\chi^2$=%.2f'%np.sum(res**2/np.reshape(np.dot(A,lstsq[:,-1]),subim.shape)/Npix))\n",
    "\n",
    "        plt.colorbar(fraction=0.046, pad=0.04)\n",
    "        plt.subplot(122)\n",
    "        res = img-np.reshape(np.dot(A,RLvals[:,0]),subim.shape)\n",
    "        Npix = np.prod(res.shape)\n",
    "        plt.imshow(res)\n",
    "        plt.title('Residuals with EM algorithm: $\\chi^2$=%.2f'%np.sum(res**2/(np.reshape(np.dot(A,RLvals[:,0]),subim.shape)+pixnoise)/Npix))\n",
    "        plt.colorbar(fraction=0.046, pad=0.04)\n",
    "        plt.figure(figsize=(10,10))\n",
    "#         plt.subplot(121)\n",
    "        lamlist,_ = calculateWaveList(par,method='lstsq')\n",
    "#         plt.plot(lstsq[:,-1])\n",
    "#         plt.plot(RLvals[:,-1])\n",
    "#         scale = np.mean(RLvals[:,-1])/np.mean(optext[4:-4,-1])\n",
    "#         plt.plot(lamlist,scale*optext[3:-3,-1])\n",
    "#         print np.mean(RLvals[:,-1]),np.mean(optext[4:-4,-1])\n",
    "\n",
    "        SNR = Nelec/(np.sqrt(Nelec+npix*pixnoise))\n",
    "        print \"Expected SNR:\",np.mean(Rvect,axis=1)[indspec]/np.sqrt(np.mean(Rvect,axis=1)[indspec]+npix*pixnoise)\n",
    "#         print \"Estimated SNR lstsq:\",estSNRlstsq[indspec]\n",
    "        print \"Estimated SNR RL:\",estSNRRL[indspec]\n",
    "        if vect is not None:\n",
    "            varray = np.array(vect)+1e-10\n",
    "            fchi2 = Rvect[:,-1]\n",
    "#             plt.subplot(122)\n",
    "            plt.plot(fchi2,label='Input')\n",
    "            plt.plot(lstsq[:,-1])\n",
    "            plt.errorbar(np.arange(N),lstsq[:,-1],yerr=np.sqrt(varlstsq[:,j]),label='lstsq')\n",
    "            plt.plot(RLvals[:,-1],label='EM')\n",
    "            plt.legend()\n",
    "            \n",
    "#             print \"MSE lstsq:\",np.sum((estSNRlstsq-fchi2)**2)/np.sum(fchi2**2)\n",
    "#             print \"MSE RL:\",np.sum((estSNRRL-fchi2)**2)/np.sum(fchi2**2)\n",
    "            print \"MSE lstsq:\",np.mean(np.sum((lstsq-Rvect)**2,axis=0)/np.sum(Rvect**2,axis=0))\n",
    "            print \"MSE RL:\",np.mean(np.sum((RLvals-Rvect)**2,axis=0)/np.sum(Rvect**2,axis=0))\n",
    "#             print \"MSRE lstsq normalized:\",np.std((estSNRlstsq-varray)/varray)\n",
    "#             print \"MSRE RL normalized:\",np.std((estSNRRL-varray)/varray)\n",
    "            \n",
    "        \n",
    "#         print \"Estimated SNR OptExt:\",estSNROptExt\n",
    "        if vect is not None: print \"Expected mean:\",np.mean(Rvect[indspec])\n",
    "        print \"Estimated mean lstsq:\",np.mean(lstsq,axis=1)[indspec]\n",
    "        print \"Estimated mean RL:\",np.mean(RLvals,axis=1)[indspec]\n",
    "        print pd.DataFrame(R)\n",
    "        print np.sum(R,axis=0)\n",
    "        print R[0],np.sum(R[0])\n",
    "#         print \"Estimated mean:\",np.mean(0.5*(optext[13,:]+optext[14,:]))\n",
    "\n",
    "    return estSNRRL#,estSNROptExt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "subPSF = PSF[:,:,:]#+PSF[1::3,:,:]+PSF[2::3,:,:])/3.\n",
    "subPSF = (PSF[:-1:2,:,:]+PSF[1::2,:,:])\n",
    "newsubPSF = np.zeros((PSF.shape[0]+1,PSF.shape[1],PSF.shape[2]))\n",
    "newsubPSF[:-1,:,:] = subPSF\n",
    "newsubPSF[-1,:,:] = 1.#/np.prod(PSF.shape[1:])\n",
    "subPSF = newsubPSF\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "subPSF = (PSF[:-1:2,:,:]+PSF[1::2,:,:])\n",
    "# newsubPSF = np.zeros((subPSF.shape[0]+1,subPSF.shape[1],subPSF.shape[2]))\n",
    "# newsubPSF[:-1,:,:] = subPSF\n",
    "# newsubPSF[-1,:,:] = 1.#/np.prod(PSF.shape[1:])\n",
    "# subPSF = newsubPSF\n",
    "subPSF = PSF[:,:,:]\n",
    "\n",
    "v = np.ones(len(lamlist))\n",
    "spec2 = spec.copy()\n",
    "# spec2[:2] = 0.0\n",
    "spec2[-1] = 0.0\n",
    "v = spec2/np.amax(spec2)\n",
    "\n",
    "Nelec = 1000\n",
    "pixnoise= 50.0\n",
    "# vect2 = (v[::3]+v[1::3]+v[2::3])\n",
    "# vect2 = (v[:-1:2]+v[1::2])*Nelec#+v[2::3]\n",
    "# newvect2 = np.zeros(vect2.shape[0]+1)\n",
    "# newvect2[:-1] = vect2*Nelec\n",
    "# newvect2[-1] = 100\n",
    "# vect2 = newvect2\n",
    "vect2 = v*Nelec\n",
    "image = np.sum(PSF*v[:,np.newaxis,np.newaxis],axis=0)\n",
    "print np.sum(image)\n",
    "image[image<0]=1e-10\n",
    "\n",
    "img = np.random.poisson(image*Nelec+pixnoise)\n",
    "plt.imshow(img)\n",
    "plt.colorbar()\n",
    "rl1 = RL(img,psflets=subPSF,prior=pixnoise,guess=np.ones(len(vect2))*Nelec,niter=10)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "rl2 = RL(img,psflets=subPSF,prior=pixnoise,guess=np.ones(len(vect2))*Nelec,niter=100)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "rl3 = RL(img,psflets=subPSF,prior=pixnoise,guess=np.ones(len(vect2))*Nelec,niter=1000)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "rl4 = RL(img,psflets=subPSF,prior=pixnoise,guess=np.ones(len(vect2))*Nelec,niter=2)[0]#np.dot(R,RL(img,psflets=psflet_subarr)[0])\n",
    "plt.figure()\n",
    "plt.plot(rl1)\n",
    "plt.plot(rl2)\n",
    "plt.plot(rl3)\n",
    "plt.plot(rl4)\n",
    "plt.plot(vect2,'o')\n",
    "plt.figure()\n",
    "psflets_flat = np.reshape(subPSF, (subPSF.shape[0], -1))\n",
    "\n",
    "plt.imshow(img-np.reshape(np.dot(psflets_flat.T,rl1),img.shape)-pixnoise)\n",
    "plt.colorbar()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
